<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>IrohaHashCustodian API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>IrohaHashCustodian</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from IrohaUtils import *
import logging
import hashlib
import threading

class BlockStorehouse():
    &#34;&#34;&#34;
    A class to track the blocks being placed on the chain, to cache the results of querying blocks
    This will allow for a speed up as we will not need to query the same low height blocks over and over
    &#34;&#34;&#34;

    def __init__(self, hashing_domain_suffix, thread_mode, conn=net_1):
        &#34;&#34;&#34;
        Set the variables for the blockstore and create a new connection that will not time out

        Args:
            hashing_domain_suffix (String): The suffix to domain names marking a domain holding hashes
            threading (boolean): 
                Set whether threading should be used or not.
                
                If threading is used (True) then a new thread is spawned that subscribes to block updates. Note this can slow down execution!
                
                If threading is not used (False) then each request to the chain causes the blockstore to update all at once
                    This removes threads but makes a request after a long delay quite slow
            conn (IrohaGrpc, optional): The connection to copy to the block store. Defaults to net_1.
        &#34;&#34;&#34;

        self.hashing_domain_suffix = hashing_domain_suffix
        self._current_height_lock = threading.Lock()
        self.current_height = 1
        self._world_state_lock = threading.Lock()
        self.world_state = {}
        self.thread_mode = thread_mode
        self._listen_thread=None
        # Create a new connection with no timeout
        self.conn = IrohaGrpc(conn._address)
        # Collect all hashes from genesis until now
        self.collect_hashes()
        if self.thread_mode:
            # Start a thread to continue to listen for new blocks
            self._listen_thread = threading.Thread(target=self.listen_for_blocks)
            # This thread really shouldn&#39;t keep anything running if main thread dies
            self._listen_thread.daemon = True
            self._listen_thread.start()
        # If we are not threading, do not start a thread 

    
    def destroy(self):
        &#34;&#34;&#34;
        Destroy this storehouse, safely cleaning up the threads (if any) and ensuring memory is released

        Returns:
            None: Returns None so we know this blockstore is destroyed
        &#34;&#34;&#34;
        if self._listen_thread is not None or self._listen_thread.is_alive():
            self.threading = False

        self.world_state = None
        return None

    
    def parse_block(self, block):
        &#34;&#34;&#34;
        Parse a block from the network, extracting hashes and storing in world_state.

        Also increases current height tracker
        &#34;&#34;&#34;

        # logging.debug(f&#34;Got block {block} at height {self.current_height}&#34;)

        # For each transaction in the block
        for tx in block.block_response.block.block_v1.payload.transactions:
            # Get the creator and the time
            current_creator_id = tx.payload.reduced_payload.creator_account_id
            current_created_time = tx.payload.reduced_payload.created_time
            # For each command in the transaction
            for command in tx.payload.reduced_payload.commands:
                # If the command is to create asset in the target domain, store this
                if command.create_asset.domain_id.endswith(self.hashing_domain_suffix):
                    # We have a new hash
                    with self._world_state_lock:
                        if command.create_asset.domain_id not in self.world_state.keys():
                            # We need to make a new entry to our world_state domains
                            self.world_state[command.create_asset.domain_id] = []
                        current_hash = {
                            &#34;hash&#34;: command.create_asset.asset_name,
                            &#34;height&#34;: self.current_height,
                            &#34;domain&#34;: command.create_asset.domain_id,
                            &#34;creator_id&#34;: current_creator_id,
                            &#34;time&#34;: current_created_time
                        }
                        self.world_state[command.create_asset.domain_id].append(current_hash)
        with self._current_height_lock:
            self.current_height+=1

    
    def collect_hashes(self):
        &#34;&#34;&#34;
        Collect all the blocks from current_height to most recent in one swoop.  

        If threading, note that this method blocks execution as the storehouse, and should only be run at start up. Once this method has completed, then the asynchronous polling can occur.  

        If not threading, this method is called at each request to allow the storehouse to catch up
        &#34;&#34;&#34;

        current_block = None
        while (current_block := get_block(self.current_height, self.conn)).error_response.error_code == 0:
            logging.debug(f&#34;Got block at height {self.current_height}&#34;)
            self.parse_block(current_block)

    
    def listen_for_blocks(self):
        &#34;&#34;&#34;
        Subscribe to blocks stream from the network
        Intended to be used as the target of a thread, to avoid blocking (no pun intended)
        &#34;&#34;&#34;

        query = admin[&#34;iroha&#34;].blocks_query()
        IrohaCrypto.sign_query(query, admin[&#34;private_key&#34;])
        for block in self.conn.send_blocks_stream_query(query):
            # logging.debug(block)
            # Check if we are still threading
            if not threading:
                # End the thread by leaving loop
                break
            self.parse_block(block)

    def get_domain_hashes(self, domain_name):
        &#34;&#34;&#34;
        Get the domain hashes from a domain, querying the world_state to avoid querying the chain

        Args:
            domain_name (String): The domain name to check for

        Returns:
            List or None: Either the list of hashes for the required domain or None (if no such domain exists in the world state)
        &#34;&#34;&#34;

        # At request, if we are not threading, catch up
        if self._listen_thread is None:
            self.collect_hashes()

        # Check if domain name is in the world state, or if there are no hashes in the domain
        if domain_name not in self.world_state.keys() or len(self.world_state[domain_name])==0:
            return None

        with self._world_state_lock:
            result = self.world_state[domain_name]
        return result

class Custodian():
    &#34;&#34;&#34;
    A class to look after hashes on the block chain
    Offering the ability to get hashes of a file, store hashes on the chain, and find hashes on the chain
    &#34;&#34;&#34;

    
    def __init__(self, hashing_domain_suffix=&#34;-hash&#34;, 
            default_domain_name=&#34;hashing&#34;, 
            hashing_role_name=&#34;hash_creator&#34;, 
            null_role_name=&#34;null_role&#34;, 
            blockstore_threading=False,
            hash_function = hashlib.md5):
        &#34;&#34;&#34;
        Create a new hash custodian, managing storage of hashes on the blockchain
        Use store_hash_on_chain to store a hash in a domain
        Use find_hash_on_chain to check if a hash exists in a domain
        Use get_domain_hashes to get ALL hashes in a domain

        Args:
            hashing_domain_suffix (str, optional): The suffix for domains that store file hashes. Defaults to &#34;-hash&#34;.
            default_domain_name (str, optional): The default domain name if no domain is given to store/find a hash. Defaults to &#34;hashing&#34;.
            hashing_role_name (str, optional): The default role name for hashing. Defaults to &#34;hash_creator&#34;.
            null_role_name (str, optional): The default role name for new domains. Will have no permissions for security. Defaults to &#34;null_role&#34;.
            blockstore_threading (bool, optional): Determines if the blockstore (cache for queries) will thread. Defaults to False.
            hash_function (hashlib.hash, optional): The hash function to use in hashing. Please note Iroha assets are capped at 32 characters, so currently only 32 character hash outputs are supported.
                Defaults to hashlib.md5
        &#34;&#34;&#34;
        
        self.hashing_domain_suffix = hashing_domain_suffix
        self.default_domain_name = default_domain_name
        self.hashing_role_name = hashing_role_name
        self.null_role_name = null_role_name
        self.block_storehouse = BlockStorehouse(self.hashing_domain_suffix, thread_mode=blockstore_threading)
        self.hash_function = hash_function
        commands = [
            # Create a new role that can only create assets (i.e. create hashes) and read assets (to see if they exist)
            iroha_admin.command(&#34;CreateRole&#34;, role_name=self.hashing_role_name, permissions=[
                    primitive_pb2.can_create_asset,
                    primitive_pb2.can_read_assets
                ]),
            # Create a new role that can do NOTHING
            iroha_admin.command(&#34;CreateRole&#34;, role_name=self.null_role_name, permissions=[
                
            ]),
            # Create a new domain that has document_creator as role
            iroha_admin.command(&#34;CreateDomain&#34;, domain_id=self.default_domain_name, default_role=self.hashing_role_name)
        ]
        tx = IrohaCrypto.sign_transaction(
            admin[&#34;iroha&#34;].transaction(commands), admin[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, net_1)
        logging.debug(status)
            

    
    def destroy(self):
        &#34;&#34;&#34;
        Destroy this custodian. Remove the blockstore (if any) and return None
        This is intended to be used if a new custodian is to be created and you want to clean up
        Especially if threads are involved with the blockstore

        Returns:
            None
        &#34;&#34;&#34;

        self.block_storehouse = self.block_storehouse.destroy()

        return None

    
    def new_hashing_user(self, user_name):
        &#34;&#34;&#34;
        Create a new user capable of hashing to the blockchain, also commits user onto chain

        Args:
            user_name (String): The name of the user to create

        Returns:
            Dictionary : A key-value store of user_id, public and private keys
        &#34;&#34;&#34;
        user = new_user(user_name, self.default_domain_name)
        commands = [
            iroha_admin.command(&#39;CreateAccount&#39;, account_name=user[&#34;name&#34;], domain_id=user[&#34;domain&#34;],
                                public_key=user[&#34;public_key&#34;])
        ]
        tx = IrohaCrypto.sign_transaction(
            admin[&#34;iroha&#34;].transaction(commands), admin[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, net_1)
        logging.debug(status)
        return user

    
    def get_file_hash(self, filename):
        &#34;&#34;&#34;
        Generate and return the MD5 hex digest of the contents of a file
        While it would be nice to use a different, more secure algorithm we are constrained
        The output of this hash will be the name of an Iroha asset, which can have max length of 32

        Args:
            filename (String): The name of the file to hash

        Returns:
            String: The hex digest of the contents of the file described by filename
        &#34;&#34;&#34;
        with open(filename, &#34;rb&#34;) as f:
            b = f.read()
            h = self.hash_function(b)
        logging.debug(h.hexdigest())
        return h.hexdigest()

    
    def get_hash(self, obj):
        &#34;&#34;&#34;
        Get the hash digest of an object

        Args:
            obj (Object, hashable): The object to hash

        Returns:
            String: The hex digest of the object
        &#34;&#34;&#34;
        obj = str(obj).encode()
        return self.hash_function(obj).hexdigest()

    def parse_domain_name(self, domain_name):
        &#34;&#34;&#34;
        Parse the given domain name to interact with the blockchain
        Currently ensures that None values are converted to the default name
        Also ensures a common suffix is applied

        Args:
            domain_name (String or None): The domain name to parse

        Returns:
            String: the domain name to use for interacting with the blockchain
        &#34;&#34;&#34;

        if domain_name is None:
            domain_name = self.default_domain_name

        if not domain_name.endswith(self.hashing_domain_suffix):
            domain_name+=self.hashing_domain_suffix

        return domain_name


    
    def _admin_create_domain(self, domain_name):
        &#34;&#34;&#34;
        Create a new domain, according to admins specifications
        This function exists so a user cannot make a domain with a specific role, as now admin gets to control this
        This function requires existence of a null_role. Passing in a role would defeat the purpose of this function


        Args:
            domain_name (String): The domain name to create

        Return:
            Boolean: True if domain exists, False otherwise
        &#34;&#34;&#34;

        commands = [
            admin[&#34;iroha&#34;].command(&#34;CreateDomain&#34;, domain_id=domain_name, default_role=self.null_role_name)
        ]
        tx = IrohaCrypto.sign_transaction(
            admin[&#34;iroha&#34;].transaction(commands), admin[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, net_1)
        logging.debug(status)
        if status[0]==&#34;COMMITTED&#34;:
            logging.debug(f&#34;New domain \&#34;{domain_name}\&#34; created&#34;)
        else:
            logging.debug(f&#34;Domain \&#34;{domain_name}\&#34; already exists&#34;)

        # Domain will always exist, look into False case later
        return True

    
    def store_hash_on_chain(self, user, h, domain_name=None, connection=net_1):
        &#34;&#34;&#34;
        Take the hex digest of a message and store this on the blockchain as the name of an asset

        Args:
            user (Dictionary): The user dictionary of the user sending this hash
            h (String): The hash of a message
            domain_name (String or None, optional): The domain name to store the hash in
                If None then use the users domain instead
                Defaults to None
            connection (IrohaGrpc, optional): The connection to send this hash over. Defaults to net_1.

        Return:
            IrohaStatus: The status of the transaction to put this hash to the chain
        &#34;&#34;&#34;

        domain_name = self.parse_domain_name(domain_name)
        

        # Try to create the domain, true if domain now exists, false otherwise
        status = self._admin_create_domain(domain_name)
        if not status:
            logging.info(&#34;Domain failed to exist!&#34;)
            # Let method continue so rejected status can be passed

        commands = [
            user[&#34;iroha&#34;].command(&#39;CreateAsset&#39;, asset_name=h,
                        domain_id=domain_name, precision=0)
        ]
        tx = IrohaCrypto.sign_transaction(
            user[&#34;iroha&#34;].transaction(commands), user[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, connection)
        logging.debug(status)
        return status

    
    def find_hash_on_chain(self, user, h, domain_name=None, connection=net_1):
        &#34;&#34;&#34;
        Given the hex digest of a message, attempt to find this hash on the blockchain

        Args:
            user (Dictionary): The user dictionary of the user querying this hash
            h (String): The hash of a message
            domain_name (String or None, optional): The domain name to search for the hash in
                If None then use the users domain instead
                Defaults to None
            connection (IrohaGrpc, optional): The connection to send this hash over. Defaults to net_1.

        Return:
            IrohaStatus: The status of this query. True if the hash exists on the blockchain, False otherwise.
        &#34;&#34;&#34;
        
        domain_name = self.parse_domain_name(domain_name)

        query = user[&#34;iroha&#34;].query(&#34;GetAssetInfo&#34;, asset_id=f&#34;{h}#{domain_name}&#34;)
        query = IrohaCrypto.sign_query(query, user[&#34;private_key&#34;])
        logging.debug(query)
        response = connection.send_query(query)
        logging.debug(response)
        #Check if response has an asset id matching the hash we are after
        return response.asset_response.asset.asset_id==f&#34;{h}#{domain_name}&#34;

    
    def get_domain_hashes(self, domain_name=None):
        &#34;&#34;&#34;
        Consult the blockstore about the domain in question

        Args:
            user (Dictionary): The user dictionary of the user querying this domain
            domain_name (String or None, optional): The domain name to search for the hash in
                If None then use the users domain instead
                Defaults to None

        Returns:
            List or None: A list of all occurrences of assets being added to this domain over the entire chain
                The elements of this list are dictionaries of:
                    hash: The name of that asset (remembering names are hashes)
                    height: The height that asset was added
                    domain: The domain of the asset, for completeness
                    creator_id: The creator of that asset
                    time: The time of creation (may be more useful than height in some cases)
                None if there is no domain (or no hashes in the domain)
        &#34;&#34;&#34;

        domain_name = self.parse_domain_name(domain_name)

        return self.block_storehouse.get_domain_hashes(domain_name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="IrohaHashCustodian.BlockStorehouse"><code class="flex name class">
<span>class <span class="ident">BlockStorehouse</span></span>
<span>(</span><span>hashing_domain_suffix, thread_mode, conn=&lt;iroha.iroha.IrohaGrpc object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to track the blocks being placed on the chain, to cache the results of querying blocks
This will allow for a speed up as we will not need to query the same low height blocks over and over</p>
<p>Set the variables for the blockstore and create a new connection that will not time out</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hashing_domain_suffix</code></strong> :&ensp;<code>String</code></dt>
<dd>The suffix to domain names marking a domain holding hashes</dd>
<dt><strong><code>threading</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<p>Set whether threading should be used or not.</p>
<p>If threading is used (True) then a new thread is spawned that subscribes to block updates. Note this can slow down execution!</p>
<p>If threading is not used (False) then each request to the chain causes the blockstore to update all at once
This removes threads but makes a request after a long delay quite slow</p>
</dd>
<dt><strong><code>conn</code></strong> :&ensp;<code>IrohaGrpc</code>, optional</dt>
<dd>The connection to copy to the block store. Defaults to net_1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlockStorehouse():
    &#34;&#34;&#34;
    A class to track the blocks being placed on the chain, to cache the results of querying blocks
    This will allow for a speed up as we will not need to query the same low height blocks over and over
    &#34;&#34;&#34;

    def __init__(self, hashing_domain_suffix, thread_mode, conn=net_1):
        &#34;&#34;&#34;
        Set the variables for the blockstore and create a new connection that will not time out

        Args:
            hashing_domain_suffix (String): The suffix to domain names marking a domain holding hashes
            threading (boolean): 
                Set whether threading should be used or not.
                
                If threading is used (True) then a new thread is spawned that subscribes to block updates. Note this can slow down execution!
                
                If threading is not used (False) then each request to the chain causes the blockstore to update all at once
                    This removes threads but makes a request after a long delay quite slow
            conn (IrohaGrpc, optional): The connection to copy to the block store. Defaults to net_1.
        &#34;&#34;&#34;

        self.hashing_domain_suffix = hashing_domain_suffix
        self._current_height_lock = threading.Lock()
        self.current_height = 1
        self._world_state_lock = threading.Lock()
        self.world_state = {}
        self.thread_mode = thread_mode
        self._listen_thread=None
        # Create a new connection with no timeout
        self.conn = IrohaGrpc(conn._address)
        # Collect all hashes from genesis until now
        self.collect_hashes()
        if self.thread_mode:
            # Start a thread to continue to listen for new blocks
            self._listen_thread = threading.Thread(target=self.listen_for_blocks)
            # This thread really shouldn&#39;t keep anything running if main thread dies
            self._listen_thread.daemon = True
            self._listen_thread.start()
        # If we are not threading, do not start a thread 

    
    def destroy(self):
        &#34;&#34;&#34;
        Destroy this storehouse, safely cleaning up the threads (if any) and ensuring memory is released

        Returns:
            None: Returns None so we know this blockstore is destroyed
        &#34;&#34;&#34;
        if self._listen_thread is not None or self._listen_thread.is_alive():
            self.threading = False

        self.world_state = None
        return None

    
    def parse_block(self, block):
        &#34;&#34;&#34;
        Parse a block from the network, extracting hashes and storing in world_state.

        Also increases current height tracker
        &#34;&#34;&#34;

        # logging.debug(f&#34;Got block {block} at height {self.current_height}&#34;)

        # For each transaction in the block
        for tx in block.block_response.block.block_v1.payload.transactions:
            # Get the creator and the time
            current_creator_id = tx.payload.reduced_payload.creator_account_id
            current_created_time = tx.payload.reduced_payload.created_time
            # For each command in the transaction
            for command in tx.payload.reduced_payload.commands:
                # If the command is to create asset in the target domain, store this
                if command.create_asset.domain_id.endswith(self.hashing_domain_suffix):
                    # We have a new hash
                    with self._world_state_lock:
                        if command.create_asset.domain_id not in self.world_state.keys():
                            # We need to make a new entry to our world_state domains
                            self.world_state[command.create_asset.domain_id] = []
                        current_hash = {
                            &#34;hash&#34;: command.create_asset.asset_name,
                            &#34;height&#34;: self.current_height,
                            &#34;domain&#34;: command.create_asset.domain_id,
                            &#34;creator_id&#34;: current_creator_id,
                            &#34;time&#34;: current_created_time
                        }
                        self.world_state[command.create_asset.domain_id].append(current_hash)
        with self._current_height_lock:
            self.current_height+=1

    
    def collect_hashes(self):
        &#34;&#34;&#34;
        Collect all the blocks from current_height to most recent in one swoop.  

        If threading, note that this method blocks execution as the storehouse, and should only be run at start up. Once this method has completed, then the asynchronous polling can occur.  

        If not threading, this method is called at each request to allow the storehouse to catch up
        &#34;&#34;&#34;

        current_block = None
        while (current_block := get_block(self.current_height, self.conn)).error_response.error_code == 0:
            logging.debug(f&#34;Got block at height {self.current_height}&#34;)
            self.parse_block(current_block)

    
    def listen_for_blocks(self):
        &#34;&#34;&#34;
        Subscribe to blocks stream from the network
        Intended to be used as the target of a thread, to avoid blocking (no pun intended)
        &#34;&#34;&#34;

        query = admin[&#34;iroha&#34;].blocks_query()
        IrohaCrypto.sign_query(query, admin[&#34;private_key&#34;])
        for block in self.conn.send_blocks_stream_query(query):
            # logging.debug(block)
            # Check if we are still threading
            if not threading:
                # End the thread by leaving loop
                break
            self.parse_block(block)

    def get_domain_hashes(self, domain_name):
        &#34;&#34;&#34;
        Get the domain hashes from a domain, querying the world_state to avoid querying the chain

        Args:
            domain_name (String): The domain name to check for

        Returns:
            List or None: Either the list of hashes for the required domain or None (if no such domain exists in the world state)
        &#34;&#34;&#34;

        # At request, if we are not threading, catch up
        if self._listen_thread is None:
            self.collect_hashes()

        # Check if domain name is in the world state, or if there are no hashes in the domain
        if domain_name not in self.world_state.keys() or len(self.world_state[domain_name])==0:
            return None

        with self._world_state_lock:
            result = self.world_state[domain_name]
        return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="IrohaHashCustodian.BlockStorehouse.collect_hashes"><code class="name flex">
<span>def <span class="ident">collect_hashes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect all the blocks from current_height to most recent in one swoop.
</p>
<p>If threading, note that this method blocks execution as the storehouse, and should only be run at start up. Once this method has completed, then the asynchronous polling can occur.
</p>
<p>If not threading, this method is called at each request to allow the storehouse to catch up</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_hashes(self):
    &#34;&#34;&#34;
    Collect all the blocks from current_height to most recent in one swoop.  

    If threading, note that this method blocks execution as the storehouse, and should only be run at start up. Once this method has completed, then the asynchronous polling can occur.  

    If not threading, this method is called at each request to allow the storehouse to catch up
    &#34;&#34;&#34;

    current_block = None
    while (current_block := get_block(self.current_height, self.conn)).error_response.error_code == 0:
        logging.debug(f&#34;Got block at height {self.current_height}&#34;)
        self.parse_block(current_block)</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.BlockStorehouse.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy this storehouse, safely cleaning up the threads (if any) and ensuring memory is released</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Returns None so we know this blockstore is destroyed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
    Destroy this storehouse, safely cleaning up the threads (if any) and ensuring memory is released

    Returns:
        None: Returns None so we know this blockstore is destroyed
    &#34;&#34;&#34;
    if self._listen_thread is not None or self._listen_thread.is_alive():
        self.threading = False

    self.world_state = None
    return None</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.BlockStorehouse.get_domain_hashes"><code class="name flex">
<span>def <span class="ident">get_domain_hashes</span></span>(<span>self, domain_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the domain hashes from a domain, querying the world_state to avoid querying the chain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>String</code></dt>
<dd>The domain name to check for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> or <code>None</code></dt>
<dd>Either the list of hashes for the required domain or None (if no such domain exists in the world state)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_domain_hashes(self, domain_name):
    &#34;&#34;&#34;
    Get the domain hashes from a domain, querying the world_state to avoid querying the chain

    Args:
        domain_name (String): The domain name to check for

    Returns:
        List or None: Either the list of hashes for the required domain or None (if no such domain exists in the world state)
    &#34;&#34;&#34;

    # At request, if we are not threading, catch up
    if self._listen_thread is None:
        self.collect_hashes()

    # Check if domain name is in the world state, or if there are no hashes in the domain
    if domain_name not in self.world_state.keys() or len(self.world_state[domain_name])==0:
        return None

    with self._world_state_lock:
        result = self.world_state[domain_name]
    return result</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.BlockStorehouse.listen_for_blocks"><code class="name flex">
<span>def <span class="ident">listen_for_blocks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscribe to blocks stream from the network
Intended to be used as the target of a thread, to avoid blocking (no pun intended)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listen_for_blocks(self):
    &#34;&#34;&#34;
    Subscribe to blocks stream from the network
    Intended to be used as the target of a thread, to avoid blocking (no pun intended)
    &#34;&#34;&#34;

    query = admin[&#34;iroha&#34;].blocks_query()
    IrohaCrypto.sign_query(query, admin[&#34;private_key&#34;])
    for block in self.conn.send_blocks_stream_query(query):
        # logging.debug(block)
        # Check if we are still threading
        if not threading:
            # End the thread by leaving loop
            break
        self.parse_block(block)</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.BlockStorehouse.parse_block"><code class="name flex">
<span>def <span class="ident">parse_block</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a block from the network, extracting hashes and storing in world_state.</p>
<p>Also increases current height tracker</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_block(self, block):
    &#34;&#34;&#34;
    Parse a block from the network, extracting hashes and storing in world_state.

    Also increases current height tracker
    &#34;&#34;&#34;

    # logging.debug(f&#34;Got block {block} at height {self.current_height}&#34;)

    # For each transaction in the block
    for tx in block.block_response.block.block_v1.payload.transactions:
        # Get the creator and the time
        current_creator_id = tx.payload.reduced_payload.creator_account_id
        current_created_time = tx.payload.reduced_payload.created_time
        # For each command in the transaction
        for command in tx.payload.reduced_payload.commands:
            # If the command is to create asset in the target domain, store this
            if command.create_asset.domain_id.endswith(self.hashing_domain_suffix):
                # We have a new hash
                with self._world_state_lock:
                    if command.create_asset.domain_id not in self.world_state.keys():
                        # We need to make a new entry to our world_state domains
                        self.world_state[command.create_asset.domain_id] = []
                    current_hash = {
                        &#34;hash&#34;: command.create_asset.asset_name,
                        &#34;height&#34;: self.current_height,
                        &#34;domain&#34;: command.create_asset.domain_id,
                        &#34;creator_id&#34;: current_creator_id,
                        &#34;time&#34;: current_created_time
                    }
                    self.world_state[command.create_asset.domain_id].append(current_hash)
    with self._current_height_lock:
        self.current_height+=1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="IrohaHashCustodian.Custodian"><code class="flex name class">
<span>class <span class="ident">Custodian</span></span>
<span>(</span><span>hashing_domain_suffix='-hash', default_domain_name='hashing', hashing_role_name='hash_creator', null_role_name='null_role', blockstore_threading=False, hash_function=&lt;built-in function openssl_md5&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to look after hashes on the block chain
Offering the ability to get hashes of a file, store hashes on the chain, and find hashes on the chain</p>
<p>Create a new hash custodian, managing storage of hashes on the blockchain
Use store_hash_on_chain to store a hash in a domain
Use find_hash_on_chain to check if a hash exists in a domain
Use get_domain_hashes to get ALL hashes in a domain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hashing_domain_suffix</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The suffix for domains that store file hashes. Defaults to "-hash".</dd>
<dt><strong><code>default_domain_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The default domain name if no domain is given to store/find a hash. Defaults to "hashing".</dd>
<dt><strong><code>hashing_role_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The default role name for hashing. Defaults to "hash_creator".</dd>
<dt><strong><code>null_role_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The default role name for new domains. Will have no permissions for security. Defaults to "null_role".</dd>
<dt><strong><code>blockstore_threading</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines if the blockstore (cache for queries) will thread. Defaults to False.</dd>
<dt><strong><code>hash_function</code></strong> :&ensp;<code>hashlib.hash</code>, optional</dt>
<dd>The hash function to use in hashing. Please note Iroha assets are capped at 32 characters, so currently only 32 character hash outputs are supported.
Defaults to hashlib.md5</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Custodian():
    &#34;&#34;&#34;
    A class to look after hashes on the block chain
    Offering the ability to get hashes of a file, store hashes on the chain, and find hashes on the chain
    &#34;&#34;&#34;

    
    def __init__(self, hashing_domain_suffix=&#34;-hash&#34;, 
            default_domain_name=&#34;hashing&#34;, 
            hashing_role_name=&#34;hash_creator&#34;, 
            null_role_name=&#34;null_role&#34;, 
            blockstore_threading=False,
            hash_function = hashlib.md5):
        &#34;&#34;&#34;
        Create a new hash custodian, managing storage of hashes on the blockchain
        Use store_hash_on_chain to store a hash in a domain
        Use find_hash_on_chain to check if a hash exists in a domain
        Use get_domain_hashes to get ALL hashes in a domain

        Args:
            hashing_domain_suffix (str, optional): The suffix for domains that store file hashes. Defaults to &#34;-hash&#34;.
            default_domain_name (str, optional): The default domain name if no domain is given to store/find a hash. Defaults to &#34;hashing&#34;.
            hashing_role_name (str, optional): The default role name for hashing. Defaults to &#34;hash_creator&#34;.
            null_role_name (str, optional): The default role name for new domains. Will have no permissions for security. Defaults to &#34;null_role&#34;.
            blockstore_threading (bool, optional): Determines if the blockstore (cache for queries) will thread. Defaults to False.
            hash_function (hashlib.hash, optional): The hash function to use in hashing. Please note Iroha assets are capped at 32 characters, so currently only 32 character hash outputs are supported.
                Defaults to hashlib.md5
        &#34;&#34;&#34;
        
        self.hashing_domain_suffix = hashing_domain_suffix
        self.default_domain_name = default_domain_name
        self.hashing_role_name = hashing_role_name
        self.null_role_name = null_role_name
        self.block_storehouse = BlockStorehouse(self.hashing_domain_suffix, thread_mode=blockstore_threading)
        self.hash_function = hash_function
        commands = [
            # Create a new role that can only create assets (i.e. create hashes) and read assets (to see if they exist)
            iroha_admin.command(&#34;CreateRole&#34;, role_name=self.hashing_role_name, permissions=[
                    primitive_pb2.can_create_asset,
                    primitive_pb2.can_read_assets
                ]),
            # Create a new role that can do NOTHING
            iroha_admin.command(&#34;CreateRole&#34;, role_name=self.null_role_name, permissions=[
                
            ]),
            # Create a new domain that has document_creator as role
            iroha_admin.command(&#34;CreateDomain&#34;, domain_id=self.default_domain_name, default_role=self.hashing_role_name)
        ]
        tx = IrohaCrypto.sign_transaction(
            admin[&#34;iroha&#34;].transaction(commands), admin[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, net_1)
        logging.debug(status)
            

    
    def destroy(self):
        &#34;&#34;&#34;
        Destroy this custodian. Remove the blockstore (if any) and return None
        This is intended to be used if a new custodian is to be created and you want to clean up
        Especially if threads are involved with the blockstore

        Returns:
            None
        &#34;&#34;&#34;

        self.block_storehouse = self.block_storehouse.destroy()

        return None

    
    def new_hashing_user(self, user_name):
        &#34;&#34;&#34;
        Create a new user capable of hashing to the blockchain, also commits user onto chain

        Args:
            user_name (String): The name of the user to create

        Returns:
            Dictionary : A key-value store of user_id, public and private keys
        &#34;&#34;&#34;
        user = new_user(user_name, self.default_domain_name)
        commands = [
            iroha_admin.command(&#39;CreateAccount&#39;, account_name=user[&#34;name&#34;], domain_id=user[&#34;domain&#34;],
                                public_key=user[&#34;public_key&#34;])
        ]
        tx = IrohaCrypto.sign_transaction(
            admin[&#34;iroha&#34;].transaction(commands), admin[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, net_1)
        logging.debug(status)
        return user

    
    def get_file_hash(self, filename):
        &#34;&#34;&#34;
        Generate and return the MD5 hex digest of the contents of a file
        While it would be nice to use a different, more secure algorithm we are constrained
        The output of this hash will be the name of an Iroha asset, which can have max length of 32

        Args:
            filename (String): The name of the file to hash

        Returns:
            String: The hex digest of the contents of the file described by filename
        &#34;&#34;&#34;
        with open(filename, &#34;rb&#34;) as f:
            b = f.read()
            h = self.hash_function(b)
        logging.debug(h.hexdigest())
        return h.hexdigest()

    
    def get_hash(self, obj):
        &#34;&#34;&#34;
        Get the hash digest of an object

        Args:
            obj (Object, hashable): The object to hash

        Returns:
            String: The hex digest of the object
        &#34;&#34;&#34;
        obj = str(obj).encode()
        return self.hash_function(obj).hexdigest()

    def parse_domain_name(self, domain_name):
        &#34;&#34;&#34;
        Parse the given domain name to interact with the blockchain
        Currently ensures that None values are converted to the default name
        Also ensures a common suffix is applied

        Args:
            domain_name (String or None): The domain name to parse

        Returns:
            String: the domain name to use for interacting with the blockchain
        &#34;&#34;&#34;

        if domain_name is None:
            domain_name = self.default_domain_name

        if not domain_name.endswith(self.hashing_domain_suffix):
            domain_name+=self.hashing_domain_suffix

        return domain_name


    
    def _admin_create_domain(self, domain_name):
        &#34;&#34;&#34;
        Create a new domain, according to admins specifications
        This function exists so a user cannot make a domain with a specific role, as now admin gets to control this
        This function requires existence of a null_role. Passing in a role would defeat the purpose of this function


        Args:
            domain_name (String): The domain name to create

        Return:
            Boolean: True if domain exists, False otherwise
        &#34;&#34;&#34;

        commands = [
            admin[&#34;iroha&#34;].command(&#34;CreateDomain&#34;, domain_id=domain_name, default_role=self.null_role_name)
        ]
        tx = IrohaCrypto.sign_transaction(
            admin[&#34;iroha&#34;].transaction(commands), admin[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, net_1)
        logging.debug(status)
        if status[0]==&#34;COMMITTED&#34;:
            logging.debug(f&#34;New domain \&#34;{domain_name}\&#34; created&#34;)
        else:
            logging.debug(f&#34;Domain \&#34;{domain_name}\&#34; already exists&#34;)

        # Domain will always exist, look into False case later
        return True

    
    def store_hash_on_chain(self, user, h, domain_name=None, connection=net_1):
        &#34;&#34;&#34;
        Take the hex digest of a message and store this on the blockchain as the name of an asset

        Args:
            user (Dictionary): The user dictionary of the user sending this hash
            h (String): The hash of a message
            domain_name (String or None, optional): The domain name to store the hash in
                If None then use the users domain instead
                Defaults to None
            connection (IrohaGrpc, optional): The connection to send this hash over. Defaults to net_1.

        Return:
            IrohaStatus: The status of the transaction to put this hash to the chain
        &#34;&#34;&#34;

        domain_name = self.parse_domain_name(domain_name)
        

        # Try to create the domain, true if domain now exists, false otherwise
        status = self._admin_create_domain(domain_name)
        if not status:
            logging.info(&#34;Domain failed to exist!&#34;)
            # Let method continue so rejected status can be passed

        commands = [
            user[&#34;iroha&#34;].command(&#39;CreateAsset&#39;, asset_name=h,
                        domain_id=domain_name, precision=0)
        ]
        tx = IrohaCrypto.sign_transaction(
            user[&#34;iroha&#34;].transaction(commands), user[&#34;private_key&#34;])
        logging.debug(tx)
        status = send_transaction(tx, connection)
        logging.debug(status)
        return status

    
    def find_hash_on_chain(self, user, h, domain_name=None, connection=net_1):
        &#34;&#34;&#34;
        Given the hex digest of a message, attempt to find this hash on the blockchain

        Args:
            user (Dictionary): The user dictionary of the user querying this hash
            h (String): The hash of a message
            domain_name (String or None, optional): The domain name to search for the hash in
                If None then use the users domain instead
                Defaults to None
            connection (IrohaGrpc, optional): The connection to send this hash over. Defaults to net_1.

        Return:
            IrohaStatus: The status of this query. True if the hash exists on the blockchain, False otherwise.
        &#34;&#34;&#34;
        
        domain_name = self.parse_domain_name(domain_name)

        query = user[&#34;iroha&#34;].query(&#34;GetAssetInfo&#34;, asset_id=f&#34;{h}#{domain_name}&#34;)
        query = IrohaCrypto.sign_query(query, user[&#34;private_key&#34;])
        logging.debug(query)
        response = connection.send_query(query)
        logging.debug(response)
        #Check if response has an asset id matching the hash we are after
        return response.asset_response.asset.asset_id==f&#34;{h}#{domain_name}&#34;

    
    def get_domain_hashes(self, domain_name=None):
        &#34;&#34;&#34;
        Consult the blockstore about the domain in question

        Args:
            user (Dictionary): The user dictionary of the user querying this domain
            domain_name (String or None, optional): The domain name to search for the hash in
                If None then use the users domain instead
                Defaults to None

        Returns:
            List or None: A list of all occurrences of assets being added to this domain over the entire chain
                The elements of this list are dictionaries of:
                    hash: The name of that asset (remembering names are hashes)
                    height: The height that asset was added
                    domain: The domain of the asset, for completeness
                    creator_id: The creator of that asset
                    time: The time of creation (may be more useful than height in some cases)
                None if there is no domain (or no hashes in the domain)
        &#34;&#34;&#34;

        domain_name = self.parse_domain_name(domain_name)

        return self.block_storehouse.get_domain_hashes(domain_name)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="IrohaHashCustodian.Custodian.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy this custodian. Remove the blockstore (if any) and return None
This is intended to be used if a new custodian is to be created and you want to clean up
Especially if threads are involved with the blockstore</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
    Destroy this custodian. Remove the blockstore (if any) and return None
    This is intended to be used if a new custodian is to be created and you want to clean up
    Especially if threads are involved with the blockstore

    Returns:
        None
    &#34;&#34;&#34;

    self.block_storehouse = self.block_storehouse.destroy()

    return None</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.Custodian.find_hash_on_chain"><code class="name flex">
<span>def <span class="ident">find_hash_on_chain</span></span>(<span>self, user, h, domain_name=None, connection=&lt;iroha.iroha.IrohaGrpc object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Given the hex digest of a message, attempt to find this hash on the blockchain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>Dictionary</code></dt>
<dd>The user dictionary of the user querying this hash</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>String</code></dt>
<dd>The hash of a message</dd>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>String</code> or <code>None</code>, optional</dt>
<dd>The domain name to search for the hash in
If None then use the users domain instead
Defaults to None</dd>
<dt><strong><code>connection</code></strong> :&ensp;<code>IrohaGrpc</code>, optional</dt>
<dd>The connection to send this hash over. Defaults to net_1.</dd>
</dl>
<h2 id="return">Return</h2>
<p>IrohaStatus: The status of this query. True if the hash exists on the blockchain, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_hash_on_chain(self, user, h, domain_name=None, connection=net_1):
    &#34;&#34;&#34;
    Given the hex digest of a message, attempt to find this hash on the blockchain

    Args:
        user (Dictionary): The user dictionary of the user querying this hash
        h (String): The hash of a message
        domain_name (String or None, optional): The domain name to search for the hash in
            If None then use the users domain instead
            Defaults to None
        connection (IrohaGrpc, optional): The connection to send this hash over. Defaults to net_1.

    Return:
        IrohaStatus: The status of this query. True if the hash exists on the blockchain, False otherwise.
    &#34;&#34;&#34;
    
    domain_name = self.parse_domain_name(domain_name)

    query = user[&#34;iroha&#34;].query(&#34;GetAssetInfo&#34;, asset_id=f&#34;{h}#{domain_name}&#34;)
    query = IrohaCrypto.sign_query(query, user[&#34;private_key&#34;])
    logging.debug(query)
    response = connection.send_query(query)
    logging.debug(response)
    #Check if response has an asset id matching the hash we are after
    return response.asset_response.asset.asset_id==f&#34;{h}#{domain_name}&#34;</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.Custodian.get_domain_hashes"><code class="name flex">
<span>def <span class="ident">get_domain_hashes</span></span>(<span>self, domain_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Consult the blockstore about the domain in question</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>Dictionary</code></dt>
<dd>The user dictionary of the user querying this domain</dd>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>String</code> or <code>None</code>, optional</dt>
<dd>The domain name to search for the hash in
If None then use the users domain instead
Defaults to None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> or <code>None</code></dt>
<dd>A list of all occurrences of assets being added to this domain over the entire chain
The elements of this list are dictionaries of:
hash: The name of that asset (remembering names are hashes)
height: The height that asset was added
domain: The domain of the asset, for completeness
creator_id: The creator of that asset
time: The time of creation (may be more useful than height in some cases)
None if there is no domain (or no hashes in the domain)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_domain_hashes(self, domain_name=None):
    &#34;&#34;&#34;
    Consult the blockstore about the domain in question

    Args:
        user (Dictionary): The user dictionary of the user querying this domain
        domain_name (String or None, optional): The domain name to search for the hash in
            If None then use the users domain instead
            Defaults to None

    Returns:
        List or None: A list of all occurrences of assets being added to this domain over the entire chain
            The elements of this list are dictionaries of:
                hash: The name of that asset (remembering names are hashes)
                height: The height that asset was added
                domain: The domain of the asset, for completeness
                creator_id: The creator of that asset
                time: The time of creation (may be more useful than height in some cases)
            None if there is no domain (or no hashes in the domain)
    &#34;&#34;&#34;

    domain_name = self.parse_domain_name(domain_name)

    return self.block_storehouse.get_domain_hashes(domain_name)</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.Custodian.get_file_hash"><code class="name flex">
<span>def <span class="ident">get_file_hash</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the MD5 hex digest of the contents of a file
While it would be nice to use a different, more secure algorithm we are constrained
The output of this hash will be the name of an Iroha asset, which can have max length of 32</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the file to hash</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>The hex digest of the contents of the file described by filename</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_hash(self, filename):
    &#34;&#34;&#34;
    Generate and return the MD5 hex digest of the contents of a file
    While it would be nice to use a different, more secure algorithm we are constrained
    The output of this hash will be the name of an Iroha asset, which can have max length of 32

    Args:
        filename (String): The name of the file to hash

    Returns:
        String: The hex digest of the contents of the file described by filename
    &#34;&#34;&#34;
    with open(filename, &#34;rb&#34;) as f:
        b = f.read()
        h = self.hash_function(b)
    logging.debug(h.hexdigest())
    return h.hexdigest()</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.Custodian.get_hash"><code class="name flex">
<span>def <span class="ident">get_hash</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the hash digest of an object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>Object, hashable</code></dt>
<dd>The object to hash</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>The hex digest of the object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hash(self, obj):
    &#34;&#34;&#34;
    Get the hash digest of an object

    Args:
        obj (Object, hashable): The object to hash

    Returns:
        String: The hex digest of the object
    &#34;&#34;&#34;
    obj = str(obj).encode()
    return self.hash_function(obj).hexdigest()</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.Custodian.new_hashing_user"><code class="name flex">
<span>def <span class="ident">new_hashing_user</span></span>(<span>self, user_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new user capable of hashing to the blockchain, also commits user onto chain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_name</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the user to create</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dictionary </code></dt>
<dd>A key-value store of user_id, public and private keys</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_hashing_user(self, user_name):
    &#34;&#34;&#34;
    Create a new user capable of hashing to the blockchain, also commits user onto chain

    Args:
        user_name (String): The name of the user to create

    Returns:
        Dictionary : A key-value store of user_id, public and private keys
    &#34;&#34;&#34;
    user = new_user(user_name, self.default_domain_name)
    commands = [
        iroha_admin.command(&#39;CreateAccount&#39;, account_name=user[&#34;name&#34;], domain_id=user[&#34;domain&#34;],
                            public_key=user[&#34;public_key&#34;])
    ]
    tx = IrohaCrypto.sign_transaction(
        admin[&#34;iroha&#34;].transaction(commands), admin[&#34;private_key&#34;])
    logging.debug(tx)
    status = send_transaction(tx, net_1)
    logging.debug(status)
    return user</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.Custodian.parse_domain_name"><code class="name flex">
<span>def <span class="ident">parse_domain_name</span></span>(<span>self, domain_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the given domain name to interact with the blockchain
Currently ensures that None values are converted to the default name
Also ensures a common suffix is applied</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>String</code> or <code>None</code></dt>
<dd>The domain name to parse</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>the domain name to use for interacting with the blockchain</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_domain_name(self, domain_name):
    &#34;&#34;&#34;
    Parse the given domain name to interact with the blockchain
    Currently ensures that None values are converted to the default name
    Also ensures a common suffix is applied

    Args:
        domain_name (String or None): The domain name to parse

    Returns:
        String: the domain name to use for interacting with the blockchain
    &#34;&#34;&#34;

    if domain_name is None:
        domain_name = self.default_domain_name

    if not domain_name.endswith(self.hashing_domain_suffix):
        domain_name+=self.hashing_domain_suffix

    return domain_name</code></pre>
</details>
</dd>
<dt id="IrohaHashCustodian.Custodian.store_hash_on_chain"><code class="name flex">
<span>def <span class="ident">store_hash_on_chain</span></span>(<span>self, user, h, domain_name=None, connection=&lt;iroha.iroha.IrohaGrpc object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Take the hex digest of a message and store this on the blockchain as the name of an asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>Dictionary</code></dt>
<dd>The user dictionary of the user sending this hash</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>String</code></dt>
<dd>The hash of a message</dd>
<dt><strong><code>domain_name</code></strong> :&ensp;<code>String</code> or <code>None</code>, optional</dt>
<dd>The domain name to store the hash in
If None then use the users domain instead
Defaults to None</dd>
<dt><strong><code>connection</code></strong> :&ensp;<code>IrohaGrpc</code>, optional</dt>
<dd>The connection to send this hash over. Defaults to net_1.</dd>
</dl>
<h2 id="return">Return</h2>
<p>IrohaStatus: The status of the transaction to put this hash to the chain</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_hash_on_chain(self, user, h, domain_name=None, connection=net_1):
    &#34;&#34;&#34;
    Take the hex digest of a message and store this on the blockchain as the name of an asset

    Args:
        user (Dictionary): The user dictionary of the user sending this hash
        h (String): The hash of a message
        domain_name (String or None, optional): The domain name to store the hash in
            If None then use the users domain instead
            Defaults to None
        connection (IrohaGrpc, optional): The connection to send this hash over. Defaults to net_1.

    Return:
        IrohaStatus: The status of the transaction to put this hash to the chain
    &#34;&#34;&#34;

    domain_name = self.parse_domain_name(domain_name)
    

    # Try to create the domain, true if domain now exists, false otherwise
    status = self._admin_create_domain(domain_name)
    if not status:
        logging.info(&#34;Domain failed to exist!&#34;)
        # Let method continue so rejected status can be passed

    commands = [
        user[&#34;iroha&#34;].command(&#39;CreateAsset&#39;, asset_name=h,
                    domain_id=domain_name, precision=0)
    ]
    tx = IrohaCrypto.sign_transaction(
        user[&#34;iroha&#34;].transaction(commands), user[&#34;private_key&#34;])
    logging.debug(tx)
    status = send_transaction(tx, connection)
    logging.debug(status)
    return status</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="IrohaHashCustodian.BlockStorehouse" href="#IrohaHashCustodian.BlockStorehouse">BlockStorehouse</a></code></h4>
<ul class="">
<li><code><a title="IrohaHashCustodian.BlockStorehouse.collect_hashes" href="#IrohaHashCustodian.BlockStorehouse.collect_hashes">collect_hashes</a></code></li>
<li><code><a title="IrohaHashCustodian.BlockStorehouse.destroy" href="#IrohaHashCustodian.BlockStorehouse.destroy">destroy</a></code></li>
<li><code><a title="IrohaHashCustodian.BlockStorehouse.get_domain_hashes" href="#IrohaHashCustodian.BlockStorehouse.get_domain_hashes">get_domain_hashes</a></code></li>
<li><code><a title="IrohaHashCustodian.BlockStorehouse.listen_for_blocks" href="#IrohaHashCustodian.BlockStorehouse.listen_for_blocks">listen_for_blocks</a></code></li>
<li><code><a title="IrohaHashCustodian.BlockStorehouse.parse_block" href="#IrohaHashCustodian.BlockStorehouse.parse_block">parse_block</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="IrohaHashCustodian.Custodian" href="#IrohaHashCustodian.Custodian">Custodian</a></code></h4>
<ul class="two-column">
<li><code><a title="IrohaHashCustodian.Custodian.destroy" href="#IrohaHashCustodian.Custodian.destroy">destroy</a></code></li>
<li><code><a title="IrohaHashCustodian.Custodian.find_hash_on_chain" href="#IrohaHashCustodian.Custodian.find_hash_on_chain">find_hash_on_chain</a></code></li>
<li><code><a title="IrohaHashCustodian.Custodian.get_domain_hashes" href="#IrohaHashCustodian.Custodian.get_domain_hashes">get_domain_hashes</a></code></li>
<li><code><a title="IrohaHashCustodian.Custodian.get_file_hash" href="#IrohaHashCustodian.Custodian.get_file_hash">get_file_hash</a></code></li>
<li><code><a title="IrohaHashCustodian.Custodian.get_hash" href="#IrohaHashCustodian.Custodian.get_hash">get_hash</a></code></li>
<li><code><a title="IrohaHashCustodian.Custodian.new_hashing_user" href="#IrohaHashCustodian.Custodian.new_hashing_user">new_hashing_user</a></code></li>
<li><code><a title="IrohaHashCustodian.Custodian.parse_domain_name" href="#IrohaHashCustodian.Custodian.parse_domain_name">parse_domain_name</a></code></li>
<li><code><a title="IrohaHashCustodian.Custodian.store_hash_on_chain" href="#IrohaHashCustodian.Custodian.store_hash_on_chain">store_hash_on_chain</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>